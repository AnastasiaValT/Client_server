1)Прочитать про клиент-серверную архитектуру

Файл – серверная архитектура – данные в виде одного или нескольких файлов размещаются на файловом сервере. Файловый сервер принимает запросы, поступающие по сети от компьютеров – клиентов, и передает им требуемые данные. Однако, обработка этих данных выполняется на компьютерах- клиентах.

Клиент - серверная архитектура – это такая архитектура, в которой сетевая нагрузка распределяется между поставщиками услуг, которые называются серверами и заказчиками услуг, которые называются клиентами.
В архитектуре клиент – сервер -  сервер базы данных не только обеспечивает доступ к общим данным, но и берет на себя всю обработку этих данных. Клиент посылает на сервер запросы на чтение или изменение данных. Сервер сам выполняет все необходимые изменения или выборки, контролируя при этом целостность и согласованность данных, и результаты в виде набора записей или кода возврата посылает на компьютер клиента. 
Недостатки файл – серверной архитектуры
–данные хранятся в одном месте, а обрабатываются в другом. Это означает, что их нужно передавать по сети, что приводит к очень высоким нагрузкам на сеть и резкому снижение производительности приложения при увеличении числа одновременно работающих клиентов.
-децентрализованное решение проблем целостности и согласованности данных и одновременного доступа к ним. Такое решение снижает надежность приложения.

Архитектура клиент – сервер лишена этих недостатков, кроме того, она позволяет оптимальным образом распределить вычислительную нагрузку между клиентом и сервером, что также влияет на характеристики системы – стоимость, производительность, поддержку

Сервер или клиент — это функции, которые выполняет компьютер. Любой компьютер в сети может выполнять функции сервера или клиента, а может выполнять обе эти функции одновременно. Все зависит от программного обеспечения.

В одноранговой сети все компьютеры равноправны: нет иерархии среди компьютеров и нет выделенного (dedicated) сервера. Как правило, каждый компьютер функционирует и как клиент, и как сервер; иначе говоря, нет отдельного компьютера, ответственного за администрирование всей сети. Все пользователи самостоятельно решают, какие данные на своем компьютере сделать общедоступными по сети. Одноранговые сети называют также рабочими группами. Рабочая группа — это небольшой коллектив, поэтому в одноранговых сетях чаще всего не более 30 компьютеров.
Если к сети подключено более 30 пользователей, то одноранговая сеть, где компьютеры выступают в роли и клиентов, и серверов, может оказаться недостаточно производительной. Поэтому большинство сетей использует выделенные серверы. Выделенным называется такой сервер, который функционирует только как сервер (исключая функции клиента или рабочей станции). Они специально оптимизированы для быстрой обработки запросов от сетевых клиентов и для управления защитой файлов и каталогов
В некоторых случаях компьютер может быть одновременно и клиентом, и сервером. Это значит, что он может предоставлять свои ресурсы и хранимые данные другим компьютерам и одновременно использовать их ресурсы и данные.

Двухуровневая система клиент - сервер - вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами.
Многоуровневая система клиент - сервер - разновидность архитектуры клиент-сервер, в которой функция обработки данных вынесена на один или несколько отдельных серверов.
Частные случаи многоуровневой архитектуры: трехуровневая архитектура, сеть с выделенным сервером.
Трехуровневая архитектура  - архитектурная модель программного комплекса, предполагающая наличие в нем трех компонентов: клиентского, сервера приложений, к которому подключено клиентское приложение, и сервера базы данных, с которым работает сервер приложений.
Сеть с выделенным сервером - это локальная вычислительная сеть, в которой сетевые устройства централизованы и управляются одним или несколькими серверами. Индивидуальные рабочие станции или клиенты должны обращаться к ресурсам сети через серверы. 

2)Что такое HTTP и HTTPS

HTTP – это протокол передачи информации в интернете, который расшифровывается как «протокол передачи гипертекста» (HyperText Transfer Protocol).
HTTPS – это расширение протокола HTTP, которое обеспечивает защиту передаваемых данных (с добавленными методами шифрования данных и проверки безопасности)
Для чего нужен HTTP
Задача, которая традиционно решается с помощью протокола HTTP  - обмен данными между пользовательским приложением, осуществляющим доступ к веб – ресурсам (обычно это веб-браузер ) и веб-сервером. 
Изначально HTTP использовался только для гипертекстовых документов, но сейчас он может передавать любую информацию. Гипертекстовые документы также могут содержать гиперcсылки, при нажатии на которые формируется новый http-запрос, в ответе на который может содержаться другой гипертекстовый документ. Таким образом мы перемещаемся по страницам в интернете.
И клиент, и сервер могут посылать друг другу заголовки и тело ответа, но в случае с клиентом доступные заголовки будут одни, а с сервером — другие. Рассмотрим пошагово, как будет выглядеть работа по протоколу HTTP в случае, когда пользователь хочет загрузить главную страницу социальной сети «Вконтакте».

1. Браузер пользователя устанавливает соединение с сервером vk.com и отправляет следующий запрос:

GET / HTTP/1.1
Host: vk.com
2. Сервер принимает запрос и отправляет ответ:
HTTP/1.1 200 OK
Server: Apache

<html>
<head>
  <title>ВКонтакте</title>
</head>
<!-- остальной контент страницы ниже -->

3. Браузер принимает ответ и показывает готовую страницу
Больше всего нам интересен самый первый шаг, где браузер инициирует запрос к серверу vk.com
Рассмотрим подробнее, что там происходит. Первая строка запроса определяет несколько важных параметров, а именно:
•Метод, которым будет запрошен контент;
•Адрес страницы;
•Версию протокола.
GET — это метод (глагол), который мы применяем для доступа к указанной странице.
GET является самым часто используемым методом, потому что он говорит серверу о том, что клиент всего лишь хочет прочитать указанный документ. Но помимо GET есть и другие методы, один из них мы рассмотрим уже в следующем разделе.
После метода идет указание на адрес страницы — URI (универсальный идентификатор ресурса). В нашем случае мы запрашиваем главную страницу сайта, поэтому используется просто слэш — /.
Последним в этой строке идет версия протокола и почти всегда это будет HTTP/1.1
После строки с указанием основных параметров всегда следует перечисление заголовков, которые передают серверу дополнительную полезную информацию: название и версию браузера, язык, кодировку, параметры кэширования и так далее.
Среди всех этих заголовков, которые передаются при каждом запросе, есть один обязательный и самый важный — это заголовок Host. Он определяет адрес домена, который запрашивает браузер клиента.
Сервер, получив запрос, ищет у себя сайт с доменом из заголовка Host, а также указанную страницу.
Если запрошенный сайт и страница найдены, клиенту отправляется ответ:
HTTP/1.1 200 OK
Такой ответ означает, что всё хорошо, документ найден и будет отправлен клиенту. 
HTTP 
HTTP/Версия Код состояния Пояснение
Больше всего здесь интересен именно код состояния, он же код ответа сервера.
В этом примере код ответа — 200, что означает: сервер работает, документ найден и будет передан клиенту. Но не всегда всё идет гладко.
Например, запрошенный документ может отсутствовать или сервер будет перегружен, в таком случае клиент не получит контент, а код ответа будет отличным от 200.
•404 — если сервер доступен, но запрошённый документ не найден;
•503 — если сервер не может обрабатывать запросы по техническим причинам.
Спецификация HTTP 1.1 определяет 40 различных кодов HTTP.
После стартовой строки следуют заголовки, а затем тело ответа.

HTTP-запрос состоит из трех элементов:
•стартовой строки, которая задает параметры запроса или ответа,
•заголовка, который описывает сведения о передаче и другую служебную информацию.
•тело (его не всегда можно встретить в структуре). Обычно в нем как раз лежат передаваемые данные. От заголовка тело отделяется пустой строкой.
Важнейшим элементом структуры запроса является стартовая строка. Благодаря ей сервер понимает, что от него хотят. Вот как она устроена:
Метод + URL + HTTP/Версия

3)HTTP методы

Безопасные, идемпотентные и неидемпотентные методы
Все вышеперечисленные методы можно разделить на три группы:
•безопасные (GET, HEAD, OPTIONS) — не изменяют данные, их можно выполнять в любой последовательности;
•идемпотентные (GET, HEAD, PUT, DELETE, OPTIONS, TRACE) — при повторном выполнении результаты будут ожидаемо одинаковыми;
•неидемпотентные (POST, PATCH) — при повторном выполнении результаты будут разными, если, например, отправить POST-запрос на создание элемента несколько раз подряд, то он может создать несколько элементов с одинаковыми данными.
Если по какой-то причине встроенных методов в спецификации HTTP недостаточно, можно использовать собственные кастомные методы. Для этого нужно чтобы сервер знал об их существовании и понимал как обрабатывать запросы с этими методами.

Метод (иногда его называют HTTP-глаголом) – описывает, какое именно действие нужно совершить со страницей. Можно придумать самые разные, но стандартных методов девять: GET, HEAD, POST, PUT, DELETE,CONNECT, OPTIONS, TRACE, PATCH. Их функциональность раскрывается в названии, они позволяют получить данные (GET), отправить данные на сервер (POST), удалить (DELETE) или заменить часть (PATCH).
Чаще всего используют GET и POST, они нужны для чтения и отправки данных на сервер. Например вы зашли в соцсеть, увидели пост и решили оставить комментарий. Или зашли в интернет-магазин, решили что-то купить и оставили данные карты.

4)HTTP статус коды сервера

Код состояния (Status Code) — три цифры (первая из которых указывает на класс состояния), которые определяют результат совершения запроса.
Информационные (1xx)
Коды состояния, которые информируют о процессе. В HTTP-ответе сервер не должен отправлять тело сообщения.
•100 Continue — сервер дает разрешение клиенту на продолжение отправки заголовков.
•101 Switching Protocols — переключение протоколов на сервере, исходя из указаний клиента, переданных в заголовке Upgrade.
•102 Processing — запрос помещен в обработку, которая будет выполняться какое-то время. Не дает клиенту разорвать соединение даже если будет превышено время ожидания.
Успешные (2xx)
Коды состояния, информирующие об успешной обработке HTTP-запроса.
•200 OK — успех и возврат всех запрошенных данных, если данные были запрошены.
•201 Created — если запрос успешен, и создался новый ресурс. Возвращает URI нового ресурса в заголовке Location и в теле сообщения ответа, также может возвращать в теле ответа и другие метаданные ресурса.
•202 Accepted — запрос помещен в обработку, клиент может разрывать соединение и не дожидаться окончания отправки сообщения.
•203 Non-Authoritative Information — в отличие от 200 OK возвращаемая информация возможна ненадежная (неактуальная), так как получена не из первоисточника (вспомогательного сервера, бекапа и т. д.).
•204 No Content — успех и возврат заголовков в ответе без тела.
•205 Reset Content — успех и сброс пользовательских данных, тело сообщения не передается.
•206 Partial Content — успех частичного запроса, выполненного методом GET, и возврат только части сообщения. Диапазоны частей контента указываются в заголовке Content-Range.
•207 Multi-Status — успех и возврат результатов более чем одной независимой операции в теле сообщения в XML-формате.
•208 Already Reported — возвращается, если уже были запрошены и отправлены ранее результаты с ответом 206 Multi-Status.
•226 IM Used — успех и возврат данных, исходя из параметров, переданных в заголовке A-IM.
Перенаправления (3xx)
Коды состояния, сообщающие клиенту что нужно совершить запрос на другой URI, который указывается в заголовке Location ответного сообщения. Во всех случаях перенаправленный запрос должен осуществляться тем же методом, что и исходный, кроме случая, если по исходному запросу вернулся ответ 303 See Other.
•300 Multiple Choices — в ответе возвращается перечисление альтернативных вариантов для перенаправления, выбор может производиться пользователем или клиентом автоматически.
•301 Moved Permanently — информирует об окончательном переносе запрашиваемого ресурса на другой URI.
•302 Found или 302 Moved Temporarily — информирует о временном переносе запрашиваемого ресурса на другой URI.
•303 See Other — информирует о том, что нужно совершать перенаправление только методом GET.
304 Not Modified — информирует о том, что ресурс не был изменен с конкретного момента, будет возвращен только если исходный запрос был произведен методом GET с содержанием заголовка If-Modified-Since или If-None-Match.
•305 Use Proxy — информирует о том, что запрос должен производиться через прокси-сервер, возвращается только исходным сервером.
•307 Temporary Redirect — аналогичен 302 коду, но в отличие от 302 гарантирует, что метод и тело не будут изменены при перенаправлении.
•308 Permanent Redirect — аналогичен 301 коду, но в отличие от 301 гарантирует, что метод и тело не будут изменены при перенаправлении.
Ошибки клиента (4xx)
Коды состояния, указывающие на ошибку со стороны клиента. Если запрос не произведен методом HEAD, то в теле ответа сервера должно присутствовать описание произошедшей ошибки.
•400 Bad Request — ошибка синтаксиса в запросе.
•401 Unauthorized — для обработки запроса требуется аутентификация.
•402 Payment Required — для обработки запроса требуется оплата.
•403 Forbidden — доступ запрещен, запрос не может быть обработан.
•404 Not Found — запрашиваемый ресурс по-указанному URI не найден.
•405 Method Not Allowed — метод запроса недопустим для запрашиваемого ресурса, к ответу сервера необходимо добавить заголовок Allow с допустимыми методами.
•406 Not Acceptable — указанный URI не соответствует передаваемым параметрам заголовка запроса, если это не HEAD-запрос, то в ответе нужно перечислить необходимые параметры.
•407 Proxy Authentication Required — похож на 403 Forbidden, только авторизоваться нужно на прокси-сервере, а не на исходном сервере.
•408 Request Timeout — истекло время ожидания окончания процедуры передачи данных клиента серверу.
•409 Conflict — конфликт происходит когда одномоментно пришли запросы на изменение ресурса от нескольких клиентов.
•410 Gone — запрашиваемый ресурс существовал ранее, но был удален.
•411 Length Required — для обработки запроса, сервер ожидает, что будет передан заголовок Content-Length, а в текущем запросе он отсутствует.
•412 Precondition Failed — если в запросе был передан заголовок If-Match, и все указанные в нем условия не выполнились.
•413 Payload Too Large — размер содержимого тела запроса чересчур большой для запрашиваемого ресурса.
•414 URI Too Long — длина указанного URI в запросе чересчур большая для запрашиваемого ресурса.
•415 Unsupported Media Type — запрашиваемый ресурс не может обработать указанный в запросе тип данных.
•416 Range Not Satisfiable — переданный диапазон в заголовке запроса Range некорректен и не был передан заголовок If-Range.
•417 Expectation Failed — переданное значение в заголовке запроса Expect некорректно для ресурса.
•418 I’m a teapot — первоапрельская шутка).
•421 Misdirected Request — произошло перенаправление на сервер, который не в состоянии вернуть ответ.
•422 Unprocessable Entity — логическая ошибка содержимого тела запроса.
•423 Locked — невозможно обработать запрос, запрашиваемый ресурс заблокирован.
•424 Failed Dependency — невозможно обработать запрос, так как одна из зависимостей запрашиваемого ресурса заблокирована.
•426 Upgrade Requiredy — сервер запрашивает обновление соединения до SSL, а клиент не поддерживается SSL.
•428 Precondition Required — клиент обязательно должен передать заголовок If-Match в запросе для запрашиваемого ресурса.
•429 Too Many Requests — клиент запрашивает ресурс слишком часто за короткий промежуток времени, сервер в ответе может вернуть заголовок Retry-After с информацией когда можно будет повторно запросить ресурс.
•431 Request Header Fields Too Large — длина заголовков в запросе чересчур большая для запрашиваемого ресурса.
•451 Unavailable For Legal Reasons — запрашиваемый ресурс недоступен по юридическим причинам.
Ошибки сервера (5xx)
Коды состояния, указывающие на ошибку со стороны сервера. Если запрос не произведен методом HEAD, то в теле ответа сервера должно присутствовать описание произошедшей ошибки.
•500 Internal Server Error — внутренняя фатальная ошибка сервера, которая не дает обработать запрос клиента.
•501 Not Implemented — серверу не известен метод, по которому производится запрос.
•502 Bad Gateway — ошибка посредника (прокси-сервера), который получил некорректное ответное сообщение от следующего сервера из цепочки.
•503 Service Unavailable — сервер временно недоступен (техобслуживание, перегрузка и т.д.), в ответе может вернуть заголовок Retry-After с информацией когда можно будет повторно запросить ресурс.
•504 Gateway Timeout — ошибка посредника (прокси-сервера), истекло время ожидания окончания ответного сообщения от следующего сервера из цепочки.
•505 HTTP Version Not Supported — неподдерживаемая версия протокола, по которой запрошен сервер.
•507 Insufficient Storage — на сервере недостаточно места, чтобы обработать текущий запрос.
•508 Lop Detected — невозможно закончить обработку запроса, так как сервер столкнулся с бесконечным циклом.
•510 Not Extended — сервером не поддерживается расширение, необходимое для обработки запроса.
•511 Network Authentication Required — ответ возвращает прокси-сервер, который сообщает, что необходимо вначале пройти авторизацию в сети. Тело ответного сообщения может содержать форму авторизации или редирект на нее.

5)Что такое ядро браузера 

Браузер :

Браузер — это специальная программа, которая позволяет искать информацию в интернете, просматривать сайты, скачивать файлы любого формата, загружать аудио и видеофайлы. То есть, браузер является средним звеном между пользователем и интернетом.

Самые популярные браузеры на сегодняшний день — это Google Chrome, Opera, Firefox, Safari, Яндекс, Internet Explorer.

Независимо от вида браузера, механизм работы у всех одинаковый. Ниже мы пошагово описали, как работают браузеры

1.Пользователь открывает свой браузер и вводит адрес нужного сайта.
2.Браузер ищет сервер. Сервер — это программа, без которой не работал бы ни один сайт в интернете. Браузер ищет сервер по IP-адресу, который уникален для каждого сайта. Сначала он далеко не идет, а ищет его в кэше роутера, операционной системе или же в истории подключений, которая хранит информацию об IP-адреса сервера, если его уже посещали ранее. Если браузер там его не находит, он смотрит в DNS (Domain Name System). Она представляет собой что-то вроде телефонной книги, которая хранит информацию о том, какое доменное имя соответствует адресу.
3.Браузер пытается установить соединение с сервером. Теперь, когда браузер нашел нужный IP-адрес, он устанавливает с ним соединение с помощью специального протокола TCP/IP, который отвечает за передачу данных в интернете. Для установки соединения используется процесс “рукопожатие”(с англ. handshaking), который проходит в три этапа: серверу отправляется специальный запрос с номером последовательности и флагом SYN; потом он отправляет ответный запрос с подтверждением получения SYN — ACK; после этого сервер посылает подтверждение приема — ACK и соединение считается установленным.
4.Браузер отправляет HTTP запрос на сервер. Таким образом он запрашивает информацию для того, чтобы отобразить страницу. Эта коммуникация осуществляется с помощью GET-запроса и POST-запроса.
5.Сервер обрабатывает запрос и отправляет ответ браузеру. Запрос обрабатывается следующими веб-серверами: Apache, nginx, lighttpd. После этого сервер отправляет браузеру ответ с данными о файлах cookie, способах кэширования ну и, конечно же, контентом для отображения страницы.
6.Браузер обрабатывает ответ и отображает запрашиваемый контент. Это называется рендерингом. Пока он происходит, браузер и сервер обмениваются данными. По завершении, пользователь видит загруженную страницу.
Движок браузера - это программа, которая преобразовывает набор команд и строки кода в полноценную красивую веб-страницу. (rfr ghfdbkmyj И уже на основе движка разрабатывается браузер, обличается в более привлекательную форму и в итоге становится user-friendly. Т. е. движок — это ядро, а браузер уже оболочка.
Ядро браузера  - это такая машина, которая распознает и начинает выполнять java – скрипты, парсит HTML-ки. Т.е. это такое механизм который при подаче правильных файлов (HTML, CSS, JS), он их прочитывает и понимает, что с этим делать.

6)Какие браузеры какие ядра используют

Blink	Google Chrome, Opera 15+, Microsoft Edge	
EdgeHTML Microsoft Edge	
Gecko	Mozilla Firefox	
GtkHTML	Novell Evolution	
KHTML	Konqueror	
Prince 	Prince XML	
Robin	The Bat!	
Tasman	Microsoft Entourage	
Trident	Internet Explorer	
WebKit	Google Chrome, Safari	
XEP	Java

7)Что такое API

Популярный термин API (англ. Application Programming Interface — программный интерфейс приложения) — это набор способов и правил, по которым различные программы общаются между собой и обмениваются данными.

8)Что такое ендпоинты

Эндпоинты — это дополнительная часть в URL-адресе сайта, которая используется, чтобы показать различный контент, когда он присутствует.
Например: У вас может быть страницы «мой аккаунт», отображаемая по URL вашего yoursite.com/my-account.. Когда к этому URL добавляется конечная точка «edit-account», что превращает его в yourrsite.com/my-account/edit-account, то вместо страницы My account отображается страница Edit account.
Это позволяет нам показывать различный контент без необходимости использования нескольких страниц и шорткодов, а также уменьшает количество контента, который необходимо установить.

Один и тот же ресурс обычно имеет множество связанных конечных точек, каждая из которых имеет разные пути и методы, но возвращает различную информацию об одном и том же ресурсе. Конечные точки обычно имеют краткие описания, похожие на общее описание ресурса, только еще короче. Кроме того, конечная точка показывает только конечный путь URL ресурса, а не базовый, общий для всех конечных точек, путь

9)URL (URI, URL, URN)

URL – это уникальный адрес сайта в сети, который определяет его местонахождение в сети Интернет
URN – неизменяемая последовательность символов, определяющая только имя некоторого ресурса. Это имя определяет только название ресурса, но не говорит, как к нему подключаться.
URI -обобщенное понятие множества идентификации нашего ресурса, которое включает как URL, так и URN, и может включать их по отдельности.

10)Идемпотентные HTTP методы
идемпотентные (GET, HEAD, PUT, DELETE, OPTIONS, TRACE) — при повторном выполнении результаты будут ожидаемо одинаковыми;

11)Безопасные HTTP методы
безопасные (GET, HEAD, OPTIONS) — не изменяют данные, их можно выполнять в любой последовательности;

12)Иденфикация, Аутентификация, Авторизация
Идентификация (Identification) — процедура распознавания пользователя по его идентификатору (имени). Эта функция выполняется, когда пользователь делает попытку войти в сеть. Пользователь сообщает системе по ее запросу свой идентификатор, и система проверяет в своей базе данных его наличие.
Аутентификация (Authentication) — процедура проверки подлинности заявленного пользователя, процесса или устройства. Эта проверка позволяет достоверно убедиться, что пользователь (процесс или устройство) является именно тем, кем себя объявляет. При проведении аутентификации проверяющая сторона убеждается в подлинности проверяемой стороны, при этом проверяемая сторона тоже активно участвует в процессе обмена информацией. Обычно пользователь подтверждает свою идентификацию, вводя в систему уникальную, не известную другим пользователям информацию о себе (например, пароль или сертификат).
Авторизация (Authorization) — процедура предоставления субъекту определенных полномочий и ресурсов в данной системе. Иными словами, авторизация устанавливает сферу его действия и доступные ему ресурсы. Если система не может надежно отличить авторизованное лицо от неавторизованного, то конфиденциальность и целостность информации в этой системе могут быть нарушены. Организации необходимо четко определить свои требования к безопасности, чтобы принимать решения о соответствующих границах авторизации.

13)Что такое IP

IP-адрес – это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP означает «Интернет-протокол» – набор правил, регулирующих формат данных, отправляемых через интернет или локальную сеть.
По сути, IP-адрес – это идентификатор, позволяющий передавать информацию между устройствами в сети: он содержит информацию о местоположении устройства и обеспечивает его доступность для связи. IP-адреса позволяют различать компьютеры, маршрутизаторы и веб-сайты в интернете и являются важным компонентом работы интернета.
IP-адрес – это строка чисел, разделенных точками. IP-адреса представляют собой набор из четырех чисел, например, 192.158.1.38. Каждое число в этом наборе принадлежит интервалу от 0 до 255. Таким образом, полный диапазон IP-адресации – это адреса от 0.0.0.0 до 255.255.255.255.

14)Что такое октаты в DNS

DNS-сервер — это сервер системы DNS (Domain Name System, система доменных имен), отвечающий за сопоставление имён доменов Интернета с IP-адресами компьютеров, на которых эти домены физически находятся. DNS-серверы позволяют пользователям набирать в браузере обычные адреса сайтов и избавляют от необходимости запоминать IP-адреса.
Система Domain Name System работает следующим образом. Вы решили посетить тот или иной сайт и вводите в адресной строке браузера его URL. Строго говоря, узла с таким названием во всемирной сети не существует — в ней есть лишь узлы с числовыми IP-адресами. Именно поэтому первое, что делает браузер — обращается к DNS-серверу, который указан в настройках вашего подключения (о том, как задать такие настройки, будет подробно рассказано далее). Сервер, получив доменное имя, ищет в таблице соответствующий ему IP-адрес, и, найдя его, возвращает вашему клиентскому устройству. Лишь после этого браузер обращается непосредственно к узлу, на котором хранится интересующий вас сайт, и по протоколу HTTP получает его содержимое, которое и отображается на вашем экране.
IP- адреса представляют собой набор из четырех чисел, например 192.158.1.38, а октет – это число, разделенное точкой. 

15)Что такое порт, сколько портов у Linux сервера

Порт сервера – это цифровой идентификатор программы, обслуживающей определенные интернет соединения на прикрепленном адресе (IP). Идентификатор представляет собой набор цифр весом не более 16 Бит, то есть это может быть произвольное число от 0 до 65535, всего – 65536 номеров
Как мы знаем, любому электронному устройству, имеющему выход в сеть, присваивается индивидуальный IP-адрес. С его помощью запрашиваемые данные находят путь на ваше персональное устройство. Чтобы стала возможной поддержка одного или сразу нескольких таких соединений и нужны порты. С их помощью сервер, на котором расположен отдаленный сайт, распознает и фиксирует ваш IP, создавая соединение «сервер/персональный компьютер». По этому каналу, как по надежному мосту, данные снуют от ПК к удаленному серверу и обратно.
Зачем серверу нужен порт? Разве IP недостаточно?
Рассмотрим для примера некий достаточно мощный сервер. Для увеличения быстроты обработки информации он имеет сразу несколько полезных программных приложений:
•веб-сервер, обеспечивающий доступ к внутренним сетевым ресурсам (сайты, данные и т. д.);
•почтовый сервер, отвечающий за рассылку писем;
•FTP-сервер, через который осуществляется обмен файлами.
В этом случае сам сервер идентифицируется через IP-адрес. Однако, если мы попытаемся связаться с определенным онлайн-ресурсом только по IP, компьютер не поймет какое именно приложение нас интересует. Поэтому он не сможет вывести на экран нужную информацию, передать данные или сообщения, так как не знает точного адреса.
Цифровые идентификаторы портов помогают решить эту проблему. Так, чтобы соединиться, например, с приложением «FTP-сервер» ваш ПК должен распознать сначала IP сервера, а затем идентификатор порта самого FTP-сервера. При образовании обратной связи сервер также подключается к вашему устройству через IP-адрес и порт.
Порты так же принято разделять по категориям, основные из них:
•0-1023 — Системные порты
•1024-49151 — Зарегистрированные порты, известные так же как пользовательские
•49152-65535 — Динамические порты, так же называемые как частные
Просмотреть список приложений и портов, используемых ими, а так же комбинированных протоколов в системе Linux вы можете в файле /etc/services, посредством команды cat.
 $ cat /etc/services

16)Уровни OSI

Cетевая модель OSI (Open Systems Interconnection model) – это эталонная модель взаимодействия открытых систем. Массово не используется, но благодаря ей можно понять, как работает аппаратная и программная части сети. 

У сетевой модели OSI всего 7 уровней, расположенных в иерархическом порядке. Верхний седьмой уровень – прикладной, а нижний первый – физический. 

1 уровень – физический (L1)
На первом уровне передается сигнал и ток от оборудования отправителя к получателю. Информация отправляется в виде нулей и единиц. На каждом уровне есть свой блок данных протокола (PDU). На первом уровне PDU – это бит. Биты передаются по оптоволокну или по беспроводной сети.

К протоколам физического уровня относятся Bluetooth, Wi-Fi, TIA-449, ITU, GSM и т. д. RJ-45, RJ-11 тоже формально относятся к L1. В виде данных обработка информации начинается только на высоких уровнях модели (с 5 по 7).

2 уровень – канальный (L2)
К сети кроме отправителя и получателя практически всегда подключены другие устройства. Второй уровень отвечает за процедуру адресации, т. е. передачу информации нужному пользователю. При поступлении на L2 биты конвертируются в кадры. В результате процедуры преобразования получаются фреймы с адресом отправителя и получателя. Готовые кадры отправляются далее.

MAC и LLC – два подуровня L2. На MAC-подуровне происходит присвоение MAC-адресов пользовательским устройствам. LLC проверяет правильность передаваемой информации и автоматически если исправляет при наличии нарушений. На этом уровне работают мосты, коммутаторы и другая аппаратура.

На рынке до сих пор встречаются коммутаторы второго уровня. Они работают с MAC-адресами и не способны обрабатывать IP-адреса. Для обеспечения маршрутизации внутри виртуальных локальных сетей потребуется коммутатор третьего уровня. Их также называют многослойными. Кроме работы с MAC такие устройства могут распознавать IP-адреса и проводить тегирование ЛВС.

3 уровень – сетевой (L3)
На этом этапе определяется путь передачи данных и вводится новое понятие маршрутизации. На L3 используется 2 типа протоколов: с установкой и без установки соединения. Первый тип протоколов отправляет данные, содержащие полную информацию об отправителе и получателе. Это нужно для того, чтобы сетевые устройства получили полные адресные сведения и правильно определили путь для маршрутизации данных. Пакет будет передаваться от одного маршрутизатора (роутера) к другому, пока не попадет получателю.

Но у протоколов, работающих без установки соединения, есть один существенный минус – не соблюдение порядка передачи данных. Пользователь получит сообщения от отправителя не так, как он их отправлял, потому что разные пакеты могут быть отправлены разными маршрутами. В этом случае, прежде чем информация попадет к пользователю, она обрабатывается на L4 транспортными протоколами.

При использовании протоколов с установкой соединения данные поступают пользователю в том порядке, в котором они были отправлены. Но при их использовании сам процесс отправки информации занимает больше времени. Активнее всего на L3 используется протокол ARP для определения MAC-адреса по IP. Он также осуществляет обратное преобразование уникального идентификатора сетевого оборудования в IP.

L1, L2, L3 относятся к уровням среды. Они отвечают за перемещение данных по беспроводным сетям, кабелям, сетевому оборудованию. Более высокие уровни (с L4 по L7) называют уровнями хоста. Они взаимодействуют с пользовательскими устройствами (ПК, смартфонами, планшетами) и отвечают за представление данных.

4 уровень – транспортный (L4)
Отправка данных от отправителя к получателю регулируется отдельно. За этот процесс отвечает транспортный уровень. При передаче информации всегда теряется часть данных. Но для некоторых видов файлов (аудио, видео, фотографии) малые потери не критичны. Для передачи таких данных применяется протокол UDP. Он обеспечивает отправку пакетов без установки соединения.

При использовании UDP файл делится на датаграммы. Она содержит заголовки, которые необходимы для доставки до получателя. По этой причине датаграммы могут направляться пользователю разными маршрутами и в произвольном порядке. Если датаграмма потеряется, в файле появляется битые данные.

Если же пользователь отправляет файлы, чувствительные к потерям данных, применяется TCP. Он проверяет целостность передаваемой информации. При его использовании файл сегментируется. Но это происходит не всегда, а только с теми пакетами данных, размер которых превышает пропускную способность сетей. Сегментация также требуется, когда происходит отправка файлов по нестабильным сетям.

В повседневной работе инженеры взаимодействуют только с первыми четырьмя уровнями. Знать их особенности нужно для проектирования сетей и настройки оборудования. С остальными уровнями взаимодействуют разработчики ПО.

5 уровень – сеансовый (L5)
Этот уровень модели OSI относится к «верхним». Здесь осуществляются операции с чистыми данными. Отвечает пятый уровень за поддержку связи во время сеанса или сессии. Он обеспечивает правильное взаимодействие между приложениями, позволяет синхронизировать разные задачи, обмениваться данными. Благодаря L5 происходит поддержка и завершение сеанса.

Сеанс состоит из запросов и ответов, направляемых между разными приложениями. Сеансовый уровень используется в ПО, удаленно вызывающих процедуры. Примером работы L5 служит видеовызов в Skype или прямой эфир на широкую аудиторию. Во время сеанса нужно обеспечить синхронизованную передачу аудио и видео всем участникам конференции. За это и отвечают протоколы пятого уровня.  

6 уровень – представления данных (L6)
Протоколы L6 осуществляют кодирование и декодирование информации. Информация, передаваемая по сети, на этом уровне не меняет своего содержания. Кроме перевода данных из одного формата в другой, L6 осуществляет и другие функции:

сжатие информации для увеличения пропускной способности канала;
шифрование данных для защиты от злоумышленников;
отправка запросов на прекращение сеанса связи.
Преобразование данных осуществляется автоматически и не требует от пользователя подтверждения. При получении данных с L5 автоматически устанавливаются стандартные форматы файлов.

7 уровень – прикладной (L7)
схема модели OSIДругое название L7 – уровень приложений. Он отвечает за взаимодействие пользовательских приложений с работающей сетью. Этот уровень обеспечивает использование программами сетевых служб, отправку e-mail, обмен данными через торренты, предоставление ПО информации о сбоях и т. д. К протоколам прикладного уровня относят:

DNS;
FTP;
BOOTP;
BitTorrent;
NFS;
RTP;
SMTP и т. д.
В случае с HTTPS его принадлежность к L7 или L6 определяется способом использования. Если пользователь занимается веб-серфингом, то протокол относят к прикладному уровню. Если же осуществляется передача финансовых данных, то низкоуровневый HTTPS рассматривают как L6.

Седьмой уровень отвечает за представление данных в понятном пользователю виде. На этом этапе не происходит доставка или маршрутизация информации. Протоколы просто преобразуют данные для визуализации. Кроме преобразования данных они также обеспечивают доступ к удаленным БД, пересылают служебную информацию.

17) Хедеры http запросов

Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию с HTTP запросом или ответом. В HTTP-заголовке содержится не чувствительное к регистру название, а затем после (:) непосредственно значение. Пробелы перед значением игнорируются.
В запросе клиент должен передать URI запрашиваемого документа. Это может быть сделано в абсолютной или относительной форме. В первом случае в состав URI должны входить название протокола и имя сервера.
GET http://www.ru/index.html HTTP/1.0
Во втором случае передается только путь к документу.
GET /index.htm HTTP/1.0
В этом случае имя и порт хоста, может быть передано в строке заголовка Host:
Host: www.example.com:8001

Все заголовки разделяются на четыре основных группы:

General Headers (рус. Общие заголовки) — используются в запросах и ответах.
Request Headers (рус. Заголовки запроса) — используются только в запросах.
Response Headers (рус. Заголовки ответа) — используются только в ответах.
Entity Headers (рус. Заголовки сущности) — сопровождают каждую сущность сообщения. Используются в запросах и ответах.


Поля заголовка запроса позволяют клиенту передавать серверу дополнительную информацию о запросе и о самом клиенте.
User-Agent: - версия пользовательской программы
Accept-Language:
Accept-Charset: Указание на предпочтительный язык документа (если документ существует на нескольких языках) и предпочтительную кодировку для текстовых документов.
Accept-Encoding: Допустимые схемы сжатия передаваемой информации.
Range: Запрос части документа, например для реализации докачки файлов.
If-Modified-Since: Запрос кэшированного документа. Позволяет получать только изменившиеся документы.


